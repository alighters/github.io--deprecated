<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[David]]></title>
  <subtitle><![CDATA[READ THE FUCKING SOURCE CODE]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://david-wei.github.io/"/>
  <updated>2015-12-22T05:50:20.000Z</updated>
  <id>http://david-wei.github.io/</id>
  
  <author>
    <name><![CDATA[david.wei]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Android内存泄露代码详解]]></title>
    <link href="http://david-wei.github.io/2015/12/22/Android%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
    <id>http://david-wei.github.io/2015/12/22/Android内存泄露代码详解/</id>
    <published>2015-12-22T05:49:19.000Z</published>
    <updated>2015-12-22T05:50:20.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u5185_u5B58_u6CC4_u9732"><a href="#u5185_u5B58_u6CC4_u9732" class="headerlink" title="内存泄露"></a>内存泄露</h1><p>在开发应用的过程中，我们总会遇到内存泄露的问题。现在通过代码列出一些常见的内存泄露的情况以及解决方案。</p>
<p>在安卓中内存泄露常常出现的情况是指组件生命周期已经结束，但是其引用被其他对象持有，得不到释放引起的。常见的内存泄露的情况，主要是有两种：内部类和静态引用的问题。</p>
<h2 id="u5185_u90E8_u7C7B"><a href="#u5185_u90E8_u7C7B" class="headerlink" title="内部类"></a>内部类</h2><h3 id="u5185_u90E8_u7C7B_u7684_u79CD_u7C7B"><a href="#u5185_u90E8_u7C7B_u7684_u79CD_u7C7B" class="headerlink" title="内部类的种类"></a>内部类的种类</h3><ul>
<li>成员内部类</li>
<li>局部内部类</li>
<li>匿名内部类</li>
<li>静态内部类</li>
</ul>
<h3 id="u975E_u9759_u6001_u5185_u90E8_u7C7B_u7684_u95EE_u9898"><a href="#u975E_u9759_u6001_u5185_u90E8_u7C7B_u7684_u95EE_u9898" class="headerlink" title="非静态内部类的问题"></a>非静态内部类的问题</h3><p>问题：非静态内部类会持有其外部类的引用。而外部类则不会有这个问题，所以我们在使用内部类的时候，要慎重考虑，尽量使用静态内部类。</p>
<p><em>PS:在EffectiveJava一书中（第四章第22条：优先考虑静态成员类，P94），作者将这四种情况统一称为嵌套类，非静态内部类（除静态内部类之外的三种）统称为内部类</em></p>
<h2 id="u4EE3_u7801_u8BE6_u89E3"><a href="#u4EE3_u7801_u8BE6_u89E3" class="headerlink" title="代码详解"></a>代码详解</h2><p>对内部类有一些了解之后，我们开始结合代码对内存泄露的问题进行讲解。<br>具体的代码地址见：<a href="https://github.com/david-wei/LightersTest" target="_blank" rel="external">LightersTest的leak包</a></p>
<h3 id="u4F7F_u7528_u5E93"><a href="#u4F7F_u7528_u5E93" class="headerlink" title="使用库"></a>使用库</h3><ul>
<li><a href="https://github.com/square/leakcanary" target="_blank" rel="external">LeakCanary</a> Square出的用来记录内存泄露的工具，非常好用</li>
<li><a href="https://github.com/orhanobut/logger" target="_blank" rel="external">Logger</a> 可以详细地打印出Log信息，包括线程信息，方便查看</li>
</ul>
<h3 id="u5E38_u89C1_u8017_u65F6_u7C7B_u6CC4_u9732"><a href="#u5E38_u89C1_u8017_u65F6_u7C7B_u6CC4_u9732" class="headerlink" title="常见耗时类泄露"></a>常见耗时类泄露</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadActivity</span> <span class="keyword">extends</span> <span class="title">BaseActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span> <span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        showThreadInfo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showThreadInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        Logger.d(i++ + <span class="string">""</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，当TreadActivity的生命周期结束，就会出现内存泄露。这里，主要匿名内部类new Runnable的使用，这是一个耗时的线程操作，它会持有外部类ThreadActivity的使用。当退出TreadActivity时，因Runnable持有其引用，导致其不能释放，造成内存泄露。<strong>注意，这里的new Thread并不是一个匿名内部类，仅仅是一个变量而已，Thread类并没有在TreadActivity中定义。</strong></p>
<p>现在，针对这个ThreadActivity做一些改进。代码如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ThreadActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">BaseActivity</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void onCreate (<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        showWeakThreadInfo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void showWeakThreadInfo() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="type">MyThread</span>(<span class="keyword">new</span> <span class="type">Runnable</span>() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            public void run() &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                        <span class="type">Thread</span>.sleep(<span class="number">1000</span>);</span><br><span class="line">                        <span class="type">Logger</span>.d(i++ + <span class="string">""</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (<span class="type">InterruptedException</span> e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Thread</span> &#123;</span></span><br><span class="line">        <span class="type">WeakReference</span>&lt;<span class="type">Runnable</span>&gt; mWeakReference;</span><br><span class="line"></span><br><span class="line">        public <span class="type">MyThread</span>(<span class="type">Runnable</span> runnable) &#123;</span><br><span class="line">            mWeakReference = <span class="keyword">new</span> <span class="type">WeakReference</span>&lt;&gt;(runnable);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            <span class="keyword">super</span>.run();</span><br><span class="line">            <span class="keyword">if</span> (mWeakReference.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">                mWeakReference.get().run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，主要做的一个改进是，在MyThread中，持有一个Runable的弱引用，这样，MyThread的执行，就不会对Activity的执行产生什么影响了。但是，在使用Demo的过程中，还是会出现内存泄露的问题。为什么呢？原因在new MyThread的过程中，穿进去的参数new Runable还是持有ThreadActivity的引用，这种写法真的是<em>然并卵</em>。</p>
<h3 id="Weak_CallBack_u89E3_u51B3_u5F31_u5F15_u7528_u95EE_u9898"><a href="#Weak_CallBack_u89E3_u51B3_u5F31_u5F15_u7528_u95EE_u9898" class="headerlink" title="Weak CallBack解决弱引用问题"></a>Weak CallBack解决弱引用问题</h3><p>主要思想：就是把上面的耗时操作Thread相关代码，提取放置到一个新的类中，进一步弱化跟Activity的引用。代码如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WeakTask</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">excute</span>(<span class="params">CallBack callback</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> WeakThread(callback).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">WeakThread</span> <span class="title">extends</span> <span class="title">Thread</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WeakThread</span>(<span class="params">CallBack callback</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.call = <span class="keyword">new</span> WeakReference&lt;&gt;(callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> WeakReference&lt;CallBack&gt; call;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        @<span class="function">Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            super.run();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (call.<span class="keyword">get</span>() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    call.<span class="keyword">get</span>().onStart(i + <span class="string">""</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (call.<span class="keyword">get</span>() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        call.<span class="keyword">get</span>().onExcute(i + <span class="string">""</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        Logger.d(<span class="string">"Thread内部:"</span> + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    i++;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，使用到的CallBack仅仅做一个回调，代码如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">CallBack</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStart</span>(<span class="params">String msg</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onExcute</span>(<span class="params">String msg</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSucces</span>(<span class="params">String msg</span>)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，调用实现的代码就比较简单了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakCallbackActivity</span> <span class="keyword">extends</span> <span class="title">BaseActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setTitle(R.string.leak_weak_callback);</span><br><span class="line">        execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Logger.d(<span class="string">"execute"</span>);</span><br><span class="line">        <span class="keyword">new</span> WeakTask().excute(<span class="keyword">new</span> CallBack() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">                Logger.d(msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onExcute</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">                Logger.d(msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSucces</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">                Logger.d(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码所做的主要思想就是在耗时操作类中，持有的回调仅仅是一个弱引用，这样在Activity界面类中传入的CallBack匿名类因为弱引用是可以及时被回收掉的，就避免了Activity的泄露。</p>
<h3 id="Handler_u5F15_u8D77_u7684_u5185_u5B58_u6CC4_u9732"><a href="#Handler_u5F15_u8D77_u7684_u5185_u5B58_u6CC4_u9732" class="headerlink" title="Handler引起的内存泄露"></a>Handler引起的内存泄露</h3><p>提到Handler，我们知道在通过Handler的post以及postDelayed方法会往对应的Looper的MessageQueue中插入一条Message，而Message中的target就是指向当前的handler。这样若是handler使用的是内部类，则会持有外部类的引用。而当这条Message还没被执行，则会导致咱们的外部类不能得到释放。所以，我们在使用Handler的时候，要谨慎一些，尽量使用静态Handler，然后持有Context的弱引用。具体详解可见：<a href="http://droidyue.com/blog/2014/12/28/in-android-handler-classes-should-be-static-or-leaks-might-occur/" target="_blank" rel="external">Android中Handler引起的内存泄露</a></p>
<h2 id="u9759_u6001_u5F15_u7528"><a href="#u9759_u6001_u5F15_u7528" class="headerlink" title="静态引用"></a>静态引用</h2><p>另一种，常常出现内存泄露的问题就是静态应用了。若是当前的Activity，被一个静态变量持有，会导致当前的Activity不能及时的释放，这样就会导致内存泄露。代码如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">StaticReferenceActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">BaseActivity</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> static <span class="type">Context</span> mContext;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    public void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setTitle(<span class="type">R</span>.string.leak_static_reference);</span><br><span class="line">        mContext = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里举得例子是比较简单地，当前的StaticReferenceActivity被静态变量mContext所持有，这就要求我们在当前组件生命周期结束时（OnDestory回调）及时释放静态变量所持有的对象。这种常见的情况就是：在做一些静态初始化的过程中，会持有context的引用，譬如好多第三库都要求我们持有的是ApplicationContext的引用。还有就是我们给第三方库或者不知道其内部实现的代码，需要我们对其传入Context对象，这里我们就得小心一二了。</p>
<p>最后，这里使用到得弱引用并不是万能的，它也有自己的问题，若是当一次GC之后，它就会被回收掉，会导致我们的回调收不到。所以我们需要对使用到的耗时操作时间长短，确定使用WeakReference还是SoftWeakRefernce或者强引用做一些筛选判定。</p>
<p><strong>PS:</strong>若是还有疑问，则可以针对<a href="https://github.com/david-wei/LightersTest" target="_blank" rel="external">代码</a>进行一些修改来验证自己的猜想。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u5185_u5B58_u6CC4_u9732"><a href="#u5185_u5B58_u6CC4_u9732" class="headerlink" title="内存泄露"></a>内存泄露</h1><p>在开发应用的过程中，我们总会遇到内存泄露的问题。]]>
    </summary>
    
      <category term="内存泄露 弱引用" scheme="http://david-wei.github.io/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2-%E5%BC%B1%E5%BC%95%E7%94%A8/"/>
    
      <category term="Android" scheme="http://david-wei.github.io/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RxJava原理解析一]]></title>
    <link href="http://david-wei.github.io/2015/12/06/RxJava%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E4%B8%80/"/>
    <id>http://david-wei.github.io/2015/12/06/RxJava原理解析一/</id>
    <published>2015-12-06T15:53:00.000Z</published>
    <updated>2015-12-22T03:10:23.000Z</updated>
    <content type="html"><![CDATA[<p>初学RxJava，对其许多的API颇感神奇，所以RxJava的原理充满了兴趣。正好最近教父大头鬼也出了一篇<a href="http://blog.csdn.net/lzyzsd/article/details/50110355" target="_blank" rel="external">RxJava解析的文章</a>，本人也结合源码给出自己的理解。</p>
<p>这里主要先就一点来讲解。问题如下：</p>
<h3 id="u8BA2_u9605_u8DDF_u88AB_u8BA2_u9605_u7684_u5173_u7CFB_uFF1F_u662F_u5982_u4F55_u5B9E_u73B0_u8FD9_u4E00_u673A_u5236_u7684_uFF1F"><a href="#u8BA2_u9605_u8DDF_u88AB_u8BA2_u9605_u7684_u5173_u7CFB_uFF1F_u662F_u5982_u4F55_u5B9E_u73B0_u8FD9_u4E00_u673A_u5236_u7684_uFF1F" class="headerlink" title="订阅跟被订阅的关系？是如何实现这一机制的？"></a>订阅跟被订阅的关系？是如何实现这一机制的？</h3><ul>
<li>首先，理解OnSubscribe的概念</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Invoked when Observable.subscribe is called.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnSubscribe</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Action1</span>&lt;<span class="title">Subscriber</span>&lt;? <span class="title">super</span> <span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// cover for generics insanity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OnSubscribe继承自Action1，来看看Action1是干什么的<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * A one-argument action.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Action1</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> call(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Action1仅仅是一个参数的泛型接口，提供了使用泛型的类型来作为参数，这样就可以调用这个指定的泛型类型。<br>在此，我把这个onSubscribe理解为订阅的行为。这个行为是指，我在创建一个被观察者的时候，就是要指定这个被观察者所要发布的行为；在观察者的角度来理解，就表示观察者订阅了这些行为。</p>
<ul>
<li>理解了这个OnSubscribe之后，看看Observable的创建。这里主要看Observable的构造方法：</li>
</ul>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> Creates an Observable with a Function to execute when it is subscribed to.</span><br><span class="line"> <span class="keyword">*</span> <span class="variable">&lt;p&gt;</span></span><br><span class="line"> <span class="keyword">*</span> <span class="variable">&lt;em&gt;</span>Note:<span class="variable">&lt;/em&gt;</span> Use &#123;<span class="comment">@link #create(OnSubscribe)&#125; to create an Observable, instead of this constructor,</span></span><br><span class="line"> <span class="keyword">*</span> unless you specifically have a need for inheritance.</span><br><span class="line"> <span class="keyword">*</span> </span><br><span class="line"> <span class="keyword">*</span> <span class="comment">@param f</span></span><br><span class="line"> <span class="keyword">*</span>            &#123;<span class="comment">@link OnSubscribe&#125; to be executed when &#123;@link #subscribe(Subscriber)&#125; is called</span></span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">protected Observable(OnSubscribe<span class="variable">&lt;T&gt;</span> f) &#123;</span><br><span class="line">    this.onSubscribe = f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>额，很简单的嘛。这里主要就是需要把OnSubscribe的属性保存下来，（即咱们所订阅的行为）。这里咱们着重点放在这段代码的类注释上面：<strong>创建一个带有执行操作的被观察者，当它被订阅时，执行它的操作（即咱们提到的订阅行为）</strong>，<em>翻译的不好，欢迎拍砖啊</em>。另外，就是这里的推荐的内容了，官方希望我们尽量通过create来创建Obserable，而不是使用继承。</p>
<ul>
<li>订阅者/观察者的使用。咱们知晓了被观察者的创建，接下来就是观察者。它的实现就很简单了。主要是由一些的主要的周期函数构成。在此，就略过了。</li>
<li>订阅操作的实现。这个是咱们关注的重头戏。先看代码：</li>
</ul>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Subscription <span class="title">subscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber, Observable&lt;T&gt; observable)</span> </span>&#123;</span><br><span class="line"><span class="comment">// validate and proceed</span></span><br><span class="line">  <span class="keyword">if</span> (subscriber == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"observer can not be null"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (observable.onSubscribe == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"onSubscribe function can not be null."</span>);</span><br><span class="line">      <span class="comment">/*</span><br><span class="line">       * the subscribe function can also be overridden but generally that's not the appropriate approach</span><br><span class="line">       * so I won't mention that in the exception</span><br><span class="line">       */</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// new Subscriber so onStart it</span></span><br><span class="line">  subscriber.onStart();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*</span><br><span class="line">   * See https://github.com/ReactiveX/RxJava/issues/216 for discussion on "Guideline 6.4: Protect calls</span><br><span class="line">   * to user code from within an Observer"</span><br><span class="line">   */</span></span><br><span class="line">  <span class="comment">// if not already wrapped</span></span><br><span class="line">  <span class="keyword">if</span> (!(subscriber <span class="keyword">instanceof</span> SafeSubscriber)) &#123;</span><br><span class="line">      <span class="comment">// assign to `observer` so we return the protected version</span></span><br><span class="line">      subscriber = <span class="keyword">new</span> SafeSubscriber&lt;T&gt;(subscriber);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The code below is exactly the same an unsafeSubscribe but not used because it would </span></span><br><span class="line">  <span class="comment">// add a significant depth to already huge call stacks.</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// allow the hook to intercept and/or decorate</span></span><br><span class="line">      hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber);</span><br><span class="line">      <span class="function"><span class="keyword">return</span> hook.<span class="title">onSubscribeReturn</span><span class="params">(subscriber)</span></span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">      <span class="comment">// special handling for certain Throwable/Error/Exception types</span></span><br><span class="line">      Exceptions.throwIfFatal(e);</span><br><span class="line">      <span class="comment">// if an unhandled error occurs executing the onSubscribe we will propagate it</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          subscriber.onError(hook.onSubscribeError(e));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e2) &#123;</span><br><span class="line">          Exceptions.throwIfFatal(e2);</span><br><span class="line">          <span class="comment">// if this happens it means the onError itself failed (perhaps an invalid function implementation)</span></span><br><span class="line">          <span class="comment">// so we are unable to propagate the error correctly and will just throw</span></span><br><span class="line">          RuntimeException r = <span class="keyword">new</span> RuntimeException(<span class="string">"Error occurred attempting to subscribe ["</span> + e.getMessage() + <span class="string">"] and then again while trying to pass to onError."</span>, e2);</span><br><span class="line">          <span class="comment">// TODO could the hook be the cause of the error in the on error handling.</span></span><br><span class="line">          hook.onSubscribeError(r);</span><br><span class="line">          <span class="comment">// TODO why aren't we throwing the hook's return value.</span></span><br><span class="line">          <span class="keyword">throw</span> r;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">return</span> Subscriptions.<span class="title">unsubscribed</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码略多，能一行行读下来，还是需要相当耐心的。这里，我就从代码中获取到的知识点做些说明：1）首先也是最重要的，当执行了subscribe的方法，就开始执行Subscriber的订阅操作。2）Subscriber的onStart方法，是第一个被调用的。3）在代码中，<em>hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber)</em>，这句代码主要是获取到observable的onSubscribe属性，然后调用它的call方法，而且参数还是subscriber，很熟悉了，有木有，这就是之前所说的订阅的行为。4）在执行观察者订阅的行为的时候，可能会出现错误，通过捕捉异常，来调用subscriber的onError方法。</p>
<ul>
<li><p>总结：这里一个简单的完整的订阅与被订阅的流程就结束了，对其原理做以概括：创建一个被观察者，需要给被观察者指定其所<strong>发布的行为（onSubscribe来实现）</strong>；指定观察者时，只需指定相应的观察回调即可；在完成订阅的操作时，是先调用subscriber的onStart方法，之后通过<strong>订阅行为onSubscribe</strong>来调用subscriber完成相应的订阅操作，最后若出现异常则会回调subscriber的onError方法。</p>
</li>
<li><p>问题：因为之前看过一些RxJava的介绍文章，提到一点Subscriber的onComplete方法和onError方法是只会执行一个，记不太确切了，是不是这样。<br>但是从源码中可以看出，若是执行到onComplete的方法时候，若在其中抛出了一场，那之后Observable的subscribe方法会捕捉异常，又会调用到onError方法，所以这样看的话，onComplete和onError是有机会都执行到的。</p>
</li>
</ul>
<p>看了这个简单的订阅，产生了一些疑问，也就是接下来要去研究的问题，也是下篇要解决的问题，列举如下：</p>
<ul>
<li>TODO:<br>1) onError和onComplete的执行唯一性<br>2）多个观察者是如何处理订阅的？</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>初学RxJava，对其许多的API颇感神奇，所以RxJava的原理充满了兴趣。正好最近教父大头鬼也出了一篇<a href="http://blog.csdn.net/lzyzsd/article/details/50110355" target="_blank" rel="]]>
    </summary>
    
      <category term="RxJava" scheme="http://david-wei.github.io/tags/RxJava/"/>
    
      <category term="Android" scheme="http://david-wei.github.io/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Activity之SwipeBack原理解析]]></title>
    <link href="http://david-wei.github.io/2015/11/29/Activity%E4%B9%8BSwipeBack%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>http://david-wei.github.io/2015/11/29/Activity之SwipeBack原理解析/</id>
    <published>2015-11-29T15:09:33.000Z</published>
    <updated>2015-12-22T03:10:20.000Z</updated>
    <content type="html"><![CDATA[<p>最近在项目中遇到了使用<a href="https://github.com/ikew0ng/SwipeBackLayout" target="_blank" rel="external">SwipeBackLayout</a>来模拟ios中右滑退出当前界面的效果（<em>万恶的模仿IOS</em>），颇感神奇，然后大致研究了下其代码实现的原理，接下来就一些主要的原理做一些讲解。</p>
<h3 id="u539F_u7406_u6982_u62EC_uFF1A"><a href="#u539F_u7406_u6982_u62EC_uFF1A" class="headerlink" title="原理概括："></a>原理概括：</h3><p>通过使用SwipeBackLayout作为咱们设置contentView的Parent，之后右滑的操作，则会由咱们的最外层容器SwipeBackLayout来处理，右滑中移动的距离，则将SwipeBackLayout的childView向右移动相应的距离。移动之后左边的间隙，则在draw方法来绘制置透明色，来显示下层的界面（必须在主题中指定windowIsTranslucent为true，这样咱们才可以看到下层的activity）。</p>
<h3 id="u539F_u7406_u89E3_u6790_uFF1A"><a href="#u539F_u7406_u89E3_u6790_uFF1A" class="headerlink" title="原理解析："></a>原理解析：</h3><p>为了验证咱们的原理是否准确，咱们通过一下几个方面进行验证：</p>
<ul>
<li><strong>SwipeBackLayout是如何设置最外层container的呢？</strong><br>在SwipeBackActivity中的onPostCreate的回调中，可以发现通过SwipeBackActivityHelper的onPostCreate来执行SwipeBackLayout的attachToActivity方法。在此方法中，通过拿到decorView的子view，使用狸猫换太子，把咱们SwipeBackLayout作为根view。具体的代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attachToActivity</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    mActivity = activity;</span><br><span class="line">    TypedArray a = activity.getTheme().obtainStyledAttributes(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;</span><br><span class="line">            android.R.attr.windowBackground</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">int</span> background = a.getResourceId(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    a.recycle();</span><br><span class="line"></span><br><span class="line">    ViewGroup decor = (ViewGroup) activity.getWindow().getDecorView();</span><br><span class="line">    ViewGroup decorChild = (ViewGroup) decor.getChildAt(<span class="number">0</span>);</span><br><span class="line">    decorChild.setBackgroundResource(background);</span><br><span class="line">    decor.removeView(decorChild);</span><br><span class="line">    addView(decorChild);</span><br><span class="line">    setContentView(decorChild);</span><br><span class="line">    decor.addView(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>SwipeBackLayout的右滑操作是否是进行自己的右移操作实现？</strong><br>像这种滑动的过程中，移动的view的效果，肯定都是在OnTouchEvent中的move方法，判断坐标的改变值，之后进行view的操作来实现的。接下来，咱们找一下代码进行验证一下，通过代码查找，发现它将onTouchEvent的操作逻辑放置在<br>ViewDragHelper中进行：<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">case</span> MotionEvent.<span class="string">ACTION_MOVE:</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="typename">int</span> index = MotionEventCompat.findPointerIndex(ev, mActivePointerId);</span><br><span class="line">        <span class="keyword">final</span> <span class="typename">float</span> x = MotionEventCompat.getX(ev, index);</span><br><span class="line">        <span class="keyword">final</span> <span class="typename">float</span> y = MotionEventCompat.getY(ev, index);</span><br><span class="line">        <span class="keyword">final</span> <span class="typename">int</span> idx = (<span class="typename">int</span>) (x - mLastMotionX[mActivePointerId]);</span><br><span class="line">        <span class="keyword">final</span> <span class="typename">int</span> idy = (<span class="typename">int</span>) (y - mLastMotionY[mActivePointerId]);</span><br><span class="line"></span><br><span class="line">        dragTo(mCapturedView.getLeft() + idx, mCapturedView.getTop() + idy, idx, idy);</span><br><span class="line"></span><br><span class="line">        saveLastMotion(ev);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Check to see if any pointer is now over a draggable view.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="typename">int</span> pointerCount = MotionEventCompat.getPointerCount(ev);</span><br><span class="line">        <span class="keyword">for</span> (<span class="typename">int</span> i = <span class="number">0</span>; i &lt; pointerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="typename">int</span> pointerId = MotionEventCompat.getPointerId(ev, i);</span><br><span class="line">            <span class="keyword">final</span> <span class="typename">float</span> x = MotionEventCompat.getX(ev, i);</span><br><span class="line">            <span class="keyword">final</span> <span class="typename">float</span> y = MotionEventCompat.getY(ev, i);</span><br><span class="line">            <span class="keyword">final</span> <span class="typename">float</span> dx = x - mInitialMotionX[pointerId];</span><br><span class="line">            <span class="keyword">final</span> <span class="typename">float</span> dy = y - mInitialMotionY[pointerId];</span><br><span class="line"></span><br><span class="line">            reportNewEdgeDrags(dx, dy, pointerId);</span><br><span class="line">            <span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">                <span class="comment">// Callback might have started an edge drag.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="typename">int</span>) x, (<span class="typename">int</span>) y);</span><br><span class="line">            <span class="keyword">if</span> (checkTouchSlop(toCapture, dx, dy)</span><br><span class="line">                    &amp;&amp; tryCaptureViewForDrag(toCapture, pointerId)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        saveLastMotion(ev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在以上的代码中，发现获取了移动的距离idx和idy，之后调用了dragTo的方法。跳转到dragTo方法：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">dragTo</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> clampedX = left;</span><br><span class="line">    <span class="keyword">int</span> clampedY = top;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldLeft = mCapturedView.getLeft();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldTop = mCapturedView.getTop();</span><br><span class="line">    <span class="keyword">if</span> (dx != <span class="number">0</span>) &#123;</span><br><span class="line">        clampedX = mCallback.clampViewPositionHorizontal(mCapturedView, left, dx);</span><br><span class="line">        mCapturedView.offsetLeftAndRight(clampedX - oldLeft);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dy != <span class="number">0</span>) &#123;</span><br><span class="line">        clampedY = mCallback.clampViewPositionVertical(mCapturedView, top, dy);</span><br><span class="line">        mCapturedView.offsetTopAndBottom(clampedY - oldTop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dx != <span class="number">0</span> || dy != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> clampedDx = clampedX - oldLeft;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> clampedDy = clampedY - oldTop;</span><br><span class="line">        mCallback</span><br><span class="line">                .onViewPositionChanged(mCapturedView, clampedX, clampedY, clampedDx, clampedDy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出它是通过调用了offsetLeftAndRight跟offsetTopAndBottom来改变相应view的位置。</p>
<ul>
<li><strong>在SwipeBackLayout右滑的过程中，左边的透明部分是如何处理的？</strong><br>这部分的逻辑，在SwipeBackLayout的drawChild的方法中，可以看出一些端倪。通过childView的移动之后的具体，在移动之后的间隙出，绘制透明色跟过度的图片。看代码：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">@<span class="function">Override</span><br><span class="line"><span class="keyword">protected</span> boolean <span class="title">drawChild</span><span class="params">(Canvas canvas, View child, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">    final boolean drawContent = child == mContentView;</span><br><span class="line"></span><br><span class="line">    boolean ret = super.drawChild(canvas, child, drawingTime);</span><br><span class="line">    <span class="keyword">if</span> (mScrimOpacity &gt; <span class="number">0</span> &amp;&amp; drawContent</span><br><span class="line">            &amp;&amp; mDragHelper.getViewDragState() != ViewDragHelper.STATE_IDLE) &#123;</span><br><span class="line">        drawShadow(canvas, child);</span><br><span class="line">        drawScrim(canvas, child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawScrim</span><span class="params">(Canvas canvas, View child)</span> </span>&#123;</span><br><span class="line">    final <span class="keyword">int</span> baseAlpha = (mScrimColor &amp; <span class="number">0xff000000</span>) &gt;&gt;&gt; <span class="number">24</span>;</span><br><span class="line">    final <span class="keyword">int</span> alpha = (<span class="keyword">int</span>) (baseAlpha * mScrimOpacity);</span><br><span class="line">    final <span class="keyword">int</span> color = alpha &lt;&lt; <span class="number">24</span> | (mScrimColor &amp; <span class="number">0xffffff</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mTrackingEdge &amp; EDGE_LEFT) != <span class="number">0</span>) &#123;</span><br><span class="line">        canvas.clipRect(<span class="number">0</span>, <span class="number">0</span>, child.getLeft(), getHeight());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((mTrackingEdge &amp; EDGE_RIGHT) != <span class="number">0</span>) &#123;</span><br><span class="line">        canvas.clipRect(child.getRight(), <span class="number">0</span>, getRight(), getHeight());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((mTrackingEdge &amp; EDGE_BOTTOM) != <span class="number">0</span>) &#123;</span><br><span class="line">        canvas.clipRect(child.getLeft(), child.getBottom(), getRight(), getHeight());</span><br><span class="line">    &#125;</span><br><span class="line">    canvas.drawColor(color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawShadow</span><span class="params">(Canvas canvas, View child)</span> </span>&#123;</span><br><span class="line">    final Rect childRect = mTmpRect;</span><br><span class="line">    child.getHitRect(childRect);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mEdgeFlag &amp; EDGE_LEFT) != <span class="number">0</span>) &#123;</span><br><span class="line">        mShadowLeft.setBounds(childRect.left - mShadowLeft.getIntrinsicWidth(), childRect.top,</span><br><span class="line">                childRect.left, childRect.bottom);</span><br><span class="line">        mShadowLeft.setAlpha((<span class="keyword">int</span>) (mScrimOpacity * FULL_ALPHA));</span><br><span class="line">        mShadowLeft.draw(canvas);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mEdgeFlag &amp; EDGE_RIGHT) != <span class="number">0</span>) &#123;</span><br><span class="line">        mShadowRight.setBounds(childRect.right, childRect.top,</span><br><span class="line">                childRect.right + mShadowRight.getIntrinsicWidth(), childRect.bottom);</span><br><span class="line">        mShadowRight.setAlpha((<span class="keyword">int</span>) (mScrimOpacity * FULL_ALPHA));</span><br><span class="line">        mShadowRight.draw(canvas);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mEdgeFlag &amp; EDGE_BOTTOM) != <span class="number">0</span>) &#123;</span><br><span class="line">        mShadowBottom.setBounds(childRect.left, childRect.bottom, childRect.right,</span><br><span class="line">                childRect.bottom + mShadowBottom.getIntrinsicHeight());</span><br><span class="line">        mShadowBottom.setAlpha((<span class="keyword">int</span>) (mScrimOpacity * FULL_ALPHA));</span><br><span class="line">        mShadowBottom.draw(canvas);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以明确的看出，他正是根据不同的移动方向，来绘制咱们所需要的那块透明的过度区域。在drawScrim绘制底色，在drawShadow中绘制过渡的图片，来达到咱们所需要的效果。</p>
<h3 id="u4E0D_u8DB3_u4E4B_u5904_uFF1A"><a href="#u4E0D_u8DB3_u4E4B_u5904_uFF1A" class="headerlink" title="不足之处："></a>不足之处：</h3><p>我们从代码中可以发现，它是在decorview中给第一个子view来添加一个父view（SwipeBackLayout）来实现view滑动之后，结束当前activity的效果。注意问题来了，decorView的第一个childView是不包含状态栏的，这样在5.0上就会出现一个视觉的bug。界面在右滑的过程中，状态栏是不改变的，在确定滑动过程结束之后，才会执行activity的finish的方法，这样状态栏次啊会消失。因为在5.0上的，嗯，我的大魅族就是5.0的，亲测这个bug，5.0上系统会根据界面的头部，动态来设置状态栏的颜色，（当然代码也是可以设置的），这个视觉的bug就比较明显了。</p>
<h3 id="Demo_u5B9E_u73B0_uFF1A"><a href="#Demo_u5B9E_u73B0_uFF1A" class="headerlink" title="Demo实现："></a>Demo实现：</h3><p>现在，楼主感觉自己掌握了这个原理，就来验证是否可行，咱们通过简单的demo来实现。<a href="https://github.com/david-wei/SwipeBackPractice" target="_blank" rel="external">Demo地址</a>，主要的细节点如下：</p>
<ul>
<li>在主题中设置windowIsTransluceni为true</li>
<li>onIntercept跟onTouchEvent事件的重写，进行指定的view的移动操作。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在项目中遇到了使用<a href="https://github.com/ikew0ng/SwipeBackLayout" target="_blank" rel="external">SwipeBackLayout</a>来模拟ios中右滑退出当前界面的效果（<em>]]>
    </summary>
    
      <category term="原理讲解" scheme="http://david-wei.github.io/tags/%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3/"/>
    
      <category term="Android" scheme="http://david-wei.github.io/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ReactNative初体验HelloWorld]]></title>
    <link href="http://david-wei.github.io/2015/11/14/ReactNative%E5%88%9D%E4%BD%93%E9%AA%8CHelloWorld/"/>
    <id>http://david-wei.github.io/2015/11/14/ReactNative初体验HelloWorld/</id>
    <published>2015-11-13T16:13:21.000Z</published>
    <updated>2015-12-22T03:10:20.000Z</updated>
    <content type="html"><![CDATA[<p>近来由于ReactNative颇为火爆，所以也尝试了一把ReactNative搭建最初的HelloWorld程序。我是跟着race604大神的<a href="http://www.race604.com/react-native-for-android-start/" target="_blank" rel="external">ReactNative的专题</a>开始一步一步操作的。大家也可以参照官方的文档，下面主要记录一下，在搭建第一个ReactNative项目中遇到的坑。</p>
<ol>
<li>使用nvm下载Node4.0之后，系统默认node还一直处于低版本的情况。<br>使用nvm list命令是可以查看到node 4.0是成功安装的。出现系统Node版本还处于较低的情况。只可能是之前通过homebrew安装过Node了，解决办法是使用brew uninstall node，将brew中的Node卸载掉。</li>
<li><p>在执行brew update 的时候，发现一直失败。（提示缺少参数）<br>找到我的homebrew的目录，发现竟然没有远程仓库，不是git目录，这可叫我怎么升级啊。因为homebrew装的比较早，当时比较懵懂，可能中间误操作过什么。所以怎么办呢？</p>
<ul>
<li>1）把我本地的Homebrew的目录连接到github上的homebrew，但是发现在执行merge的过程中，冲突的东西略多（自己通过homebrew也安装了好多东西）。这就太麻烦了。切换第二种。</li>
<li>2）重命名本地homebrew的目录名称（也就是相当于删除，这里以防万一，做个备份）。再执行brew -v的时候，发现brew命令没了。那好，再按官网homebrew的安装方法重新安装一遍，再把需要用brew安装的再重新安装一遍。（这个的过程还是蛮简单的，就是比较好时而已），接下来再执行brew udpate的时候，发现没问题了。Ok.</li>
</ul>
</li>
<li><p>执行react-native init project的时候，发现好久的等待，竟然还是处于初始的状态。问了几个大神，他们说遇到这种情况，就断掉重试一下。我重试了好几次，还是没反应。可神奇的是第二天早上的时候，再执行此操作的时候，竟然神奇的下载下来了。（看来这是个人品活。。）</p>
</li>
</ol>
<p>额，就遇到这几个问题，由于懂得不是太多，解决问题的办法都比较粗暴，先简单的留下一个记录。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>近来由于ReactNative颇为火爆，所以也尝试了一把ReactNative搭建最初的HelloWorld程序。我是跟着race604大神的<a href="http://www.race604.com/react-native-for-android-start/" t]]>
    </summary>
    
      <category term="ReactNative Android" scheme="http://david-wei.github.io/tags/ReactNative-Android/"/>
    
      <category term="Android" scheme="http://david-wei.github.io/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Viewpager实现循环滚动]]></title>
    <link href="http://david-wei.github.io/2015/10/26/Viewpager%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AF%E6%BB%9A%E5%8A%A8/"/>
    <id>http://david-wei.github.io/2015/10/26/Viewpager实现循环滚动/</id>
    <published>2015-10-26T15:41:03.000Z</published>
    <updated>2015-12-22T03:10:20.000Z</updated>
    <content type="html"><![CDATA[<p>Android中常常也会出现像Web网页上图片轮播的效果，也就是实现图片的循环滚动，这里以<a href="https://github.com/imbryk/LoopingViewPager" target="_blank" rel="external">LoopingViewPager</a>为例，讲解一下如何实现viewPager的无限滚动。</p>
<p>###LoopingViewPager原理讲解<br>这里主要有两个类LoopPagerAdapterWrapper和LoopViewPager。主要的思想简单来说就是存在两个数据源，外面的数据源就是我们看到的数据项，内部的数据源，需要在开头和末尾各添加1个数据项（以A、B表示），这样相比外部的count多两项，A显示的内容跟真实数据源最后一项相同，B显示的内容跟真实数据源第一项相同。</p>
<ul>
<li>LoopPagerAdapterWrapper<br>通过继承PagerAdapter，实现PagerAdapter的功能，内部引用了一个新的pagerAdpater，实现了一个新的数据源的映射。映射的规则是这样的：<br>原始的数据源[0,1,2,3]，对应内部的数据源则是[0,1,2,3,4,5]，换算的公式则是，realPosition=(position-1)%count 对应的关系：[0-&gt;3, 1-&gt;0, 2-&gt;1, 3-&gt;2, 4-&gt;3, 5-&gt;0]。这样，内部的数据源在调用instantiateItem的时候，则会在生成对应的View的时候，调用对应realPostion位置上的View，具体的代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">toRealPosition</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> realCount = getRealCount();</span><br><span class="line">       <span class="keyword">if</span> (realCount == <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> realPosition = (position-<span class="number">1</span>) % realCount;</span><br><span class="line">       <span class="keyword">if</span> (realPosition &lt; <span class="number">0</span>)</span><br><span class="line">           realPosition += realCount;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> realPosition;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">instantiateItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> realPosition = (mAdapter <span class="keyword">instanceof</span> FragmentPagerAdapter || mAdapter <span class="keyword">instanceof</span> FragmentStatePagerAdapter)</span><br><span class="line">               ? position</span><br><span class="line">               : toRealPosition(position);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (mBoundaryCaching) &#123;</span><br><span class="line">           ToDestroy toDestroy = mToDestroy.get(position);</span><br><span class="line">           <span class="keyword">if</span> (toDestroy != <span class="keyword">null</span>) &#123;</span><br><span class="line">               mToDestroy.remove(position);</span><br><span class="line">               <span class="keyword">return</span> toDestroy.object;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> mAdapter.instantiateItem(container, realPosition);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面的代码解决了正常情况下，在边界条件下，viewpager可以滑动的问题（添加了两个边界的pagerItem的显示），但是会有一个新的问题产生，就是当我滑动到这两个新添加的pagerItem的时候，是如何可以继续向边界滑动的。</p>
<h3 id="LoopViewPager"><a href="#LoopViewPager" class="headerlink" title="LoopViewPager"></a>LoopViewPager</h3><p>通过继承Viewpager,并设置了一个内部的PagechangeListener，在onPageScrolled的回调中，发现当内部的pagerAdpater的position滑动到边界的时候，通过调用setCurrentItem，将position又设置到正确的位置。具体代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageScrolled</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">float</span> positionOffset,</span><br><span class="line">               <span class="keyword">int</span> positionOffsetPixels)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span> realPosition = position;</span><br><span class="line">           <span class="keyword">if</span> (mAdapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">               realPosition = mAdapter.toRealPosition(position);</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (positionOffset == <span class="number">0</span></span><br><span class="line">                       &amp;&amp; mPreviousOffset == <span class="number">0</span></span><br><span class="line">                       &amp;&amp; (position == <span class="number">0</span> || position == mAdapter.getCount() - <span class="number">1</span>)) &#123;</span><br><span class="line">                   setCurrentItem(realPosition, <span class="keyword">false</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           mPreviousOffset = positionOffset;</span><br><span class="line">           <span class="keyword">if</span> (mOuterPageChangeListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (realPosition != mAdapter.getRealCount() - <span class="number">1</span>) &#123;</span><br><span class="line">                   mOuterPageChangeListener.onPageScrolled(realPosition,</span><br><span class="line">                           positionOffset, positionOffsetPixels);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (positionOffset &gt; .<span class="number">5</span>) &#123;</span><br><span class="line">                       mOuterPageChangeListener.onPageScrolled(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       mOuterPageChangeListener.onPageScrolled(realPosition,</span><br><span class="line">                               <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p>综上，可以看出这是个比较简单的方案了，唯一不足的地方就是需要监听pageChangeListener的pageScroll方法，重新设置position的值（具体的方法是调用scrollTo进行重绘一遍，比较浪费性能）。</p>
<h3 id="u8FDB_u9636_u5B9E_u73B0_u81EA_u52A8_u6EDA_u52A8_u7684_u529F_u80FD"><a href="#u8FDB_u9636_u5B9E_u73B0_u81EA_u52A8_u6EDA_u52A8_u7684_u529F_u80FD" class="headerlink" title="进阶实现自动滚动的功能"></a>进阶实现自动滚动的功能</h3><p>因为Viewpager已经自带了smoothScroll的功能，则我们只需要在固定的间隔时间发送一个让viewPager滚动的message即可，这个还是比较简单而且容易实现的。</p>
<p>PS:转载请注明来自原文链接。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Android中常常也会出现像Web网页上图片轮播的效果，也就是实现图片的循环滚动，这里以<a href="https://github.com/imbryk/LoopingViewPager" target="_blank" rel="external">LoopingV]]>
    </summary>
    
      <category term="viewPager" scheme="http://david-wei.github.io/tags/viewPager/"/>
    
      <category term="Android" scheme="http://david-wei.github.io/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ListView图片加载讲解]]></title>
    <link href="http://david-wei.github.io/2015/10/18/ListView%E6%BB%91%E5%8A%A8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://david-wei.github.io/2015/10/18/ListView滑动性能优化/</id>
    <published>2015-10-18T15:24:48.000Z</published>
    <updated>2015-12-22T03:10:20.000Z</updated>
    <content type="html"><![CDATA[<p>在ListView加载图片的时候，我们就会关于这里的图片加载产生一些问题。另外，我们知道针对ListView加载图片常用的优化方案之一就是，在列表的滑动过程中，暂停图片的加载任务，在滑动结束之后，则继续之前的任务。所以我们针对这些问题进行一些探讨研究（以UIL图片加载为例）。</p>
<ul>
<li><p>知识点1：加载图片的线程的控制;<br>我们知道在ListView的adapter的getView方法中，进行图片的获取，这里为执行LoadAndDisplayImageTask，这是一个单独的线程去加载图片。但我们不会对每个View加载图片都去执行一个新的线程，所以这里采用的是一个线程池来控制线程的数目，来避免频繁地创建线程。</p>
</li>
<li><p>知识点2：在ListView的滑动过程中，是如何暂停当前的图片下载的任务的；<br> 由于这里我们采用的是单独的线程来控制图片的加载显示的，针对线程，我们使用的是加锁来使线程阻塞，当ListView滑动结束，则使其恢复。<br> 在UIL中，锁声明的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean paused = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object pauseLock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Pauses engine. All new "load&amp;display" tasks won't be executed until ImageLoader is &#123;<span class="doctag">@link</span> #resume() resumed&#125;.Already running tasks are not paused.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	paused.set(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Resumes engine work. Paused "load&amp;display" tasks will continue its work. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	paused.set(<span class="keyword">false</span>);</span><br><span class="line">	<span class="keyword">synchronized</span> (pauseLock) &#123;</span><br><span class="line">		pauseLock.notifyAll();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line"><span class="function">AtomicBoolean <span class="title">getPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> paused;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">getPauseLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> pauseLock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在LoadAndDisplayImageTask的方法中，执行图片的加载的时候，会进行pause的判断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@return</span> &lt;b&gt;true&lt;/b&gt; - if task should be interrupted; &lt;b&gt;false&lt;/b&gt; - otherwise */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">waitIfPaused</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	AtomicBoolean pause = engine.getPause();</span><br><span class="line">	<span class="keyword">if</span> (pause.get()) &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (engine.getPauseLock()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (pause.get()) &#123;</span><br><span class="line">				L.d(LOG_WAITING_FOR_RESUME, memoryCacheKey);</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					engine.getPauseLock().wait();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					L.e(LOG_TASK_INTERRUPTED, memoryCacheKey);</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				L.d(LOG_RESUME_AFTER_PAUSE, memoryCacheKey);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> isTaskNotActual();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，pause跟resume的调用，则是在UIL的PauseOnScrollListener进行滑动判断的调用。所以可以明显的看出是通过object的wait跟notifyAll实现线程同步，来达到暂停图片加载的任务的。</p>
</li>
<li><p>知识点3：当一个Item的view滑出屏幕外，应该怎么处理其对应的图片加载任务：<br>我们先要判断的是怎么确定一个view已经滑出屏幕之外了呢？这里有个取巧的办法就是判断view是否重用了，因为ListView显示界面所需要的ItemView是固定的（确保当前ListView是采用convertView的缓存机制），而在实现图片显示加载的时候，每个view是要绑定当前加载的图片的链接的，如果当前任务（是指当前View显示加载图片的线程）的图片链接与View要显示的图片链接不一致，则可以判定当前view已经重用了。所以则可以结束当前的显示图片的任务了，具体判断View重用的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@return</span> &lt;b&gt;true&lt;/b&gt; - if current ImageAware is reused for displaying another image; &lt;b&gt;false&lt;/b&gt; - otherwise */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isViewReused</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String currentCacheKey = engine.getLoadingUriForView(imageAware);</span><br><span class="line">	<span class="comment">// Check whether memory cache key (image URI) for current ImageAware is actual.</span></span><br><span class="line">	<span class="comment">// If ImageAware is reused for another task then current task should be cancelled.</span></span><br><span class="line">	<span class="keyword">boolean</span> imageAwareWasReused = !memoryCacheKey.equals(currentCacheKey);</span><br><span class="line">	<span class="keyword">if</span> (imageAwareWasReused) &#123;</span><br><span class="line">		L.d(LOG_TASK_CANCELLED_IMAGEAWARE_REUSED, memoryCacheKey);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在调用isViewReused的checkViewReused的如下，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@throws</span> TaskCancelledException if target ImageAware is collected by GC */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkViewReused</span><span class="params">()</span> <span class="keyword">throws</span> TaskCancelledException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (isViewReused()) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> TaskCancelledException();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，在线程的主体run方法中，通过调用checkTaskNotActual()判断view重用或者被回收，抛出TaskCancelledException，来结束当前的线程，并回调图片加载的cancel方法。</p>
<p>最后，我感兴趣的几个问题记录如上，有疑问，大家不吝赐教，可以一起探讨。</p>
<p>PS:转载请注明来自原文链接。</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>在ListView加载图片的时候，我们就会关于这里的图片加载产生一些问题。另外，我们知道针对ListView加载图片常用的优化方案之一就是，在列表的滑动过程中，暂停图片的加载任务，在滑动结束之后，则继续之前的任务。所以我们针对这些问题进行一些探讨研究（以UIL图片加载为例）]]>
    </summary>
    
      <category term="原理讲解" scheme="http://david-wei.github.io/tags/%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3/"/>
    
      <category term="Android" scheme="http://david-wei.github.io/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Git进阶命令]]></title>
    <link href="http://david-wei.github.io/2015/10/11/Git%E8%BF%9B%E9%98%B6%E5%91%BD%E4%BB%A4/"/>
    <id>http://david-wei.github.io/2015/10/11/Git进阶命令/</id>
    <published>2015-10-11T14:28:26.000Z</published>
    <updated>2015-12-22T03:10:20.000Z</updated>
    <content type="html"><![CDATA[<ol>
<li>添加远程仓库<br>git remote add <name> <url></url></name></li>
<li>修改远程仓库<br>git remote set-url <name> <url></url></name></li>
<li>git版本恢复<ul>
<li>所有内容恢复到上一版本 git reset HEAD^</li>
<li>文件恢复到上一版本 git reset HEAD^ <file></file></li>
<li>向前回退三个版本 git reset -soft HEAD~3</li>
</ul>
</li>
<li>git删除远程分支<br>git branch -r -d origin/branch-name<br>git push origin :branch-name</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<ol>
<li>添加远程仓库<br>git remote add <name> <url></url></name></li>
<li>修改远程仓库<br>git remote set-url <name> <url></url></name></li>
<li>git版本恢复]]>
    </summary>
    
      <category term="Git命令" scheme="http://david-wei.github.io/tags/Git%E5%91%BD%E4%BB%A4/"/>
    
      <category term="工具命令" scheme="http://david-wei.github.io/categories/%E5%B7%A5%E5%85%B7%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[常用Shell命令汇总]]></title>
    <link href="http://david-wei.github.io/2015/10/11/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/"/>
    <id>http://david-wei.github.io/2015/10/11/常用命令汇总/</id>
    <published>2015-10-11T13:31:20.000Z</published>
    <updated>2015-12-22T03:10:20.000Z</updated>
    <content type="html"><![CDATA[<ol>
<li>命令结果输出到剪贴板<ul>
<li>Mac: pwd | pbcopy</li>
<li>linux: pwd | xsel</li>
<li>windows: echo Hello | clip</li>
</ul>
</li>
<li></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<ol>
<li>命令结果输出到剪贴板<ul>
<li>Mac: pwd | pbcopy</li>
<li>linux: pwd | xsel</li>
<li>windows: echo Hello | clip</li>
</ul>
</li>
<li></li>
</ol]]>
    </summary>
    
      <category term="Linux命令" scheme="http://david-wei.github.io/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
      <category term="工具命令" scheme="http://david-wei.github.io/categories/%E5%B7%A5%E5%85%B7%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android进阶汇总一]]></title>
    <link href="http://david-wei.github.io/2015/09/17/Android%E8%BF%9B%E9%98%B6%E6%B1%87%E6%80%BB%E4%B8%80/"/>
    <id>http://david-wei.github.io/2015/09/17/Android进阶汇总一/</id>
    <published>2015-09-16T16:22:01.000Z</published>
    <updated>2015-12-22T03:10:20.000Z</updated>
    <content type="html"><![CDATA[<p>针对Android中一些进阶的常用的知识点，做一些汇总：</p>
<h3 id="BaseAdapter_u4E2Dnotifydatachanged_u539F_u7406_2C_u4F1A_u5E26_u6765_u7684_u95EE_u9898_uFF0C_u5982_u4F55_u89E3_u51B3"><a href="#BaseAdapter_u4E2Dnotifydatachanged_u539F_u7406_2C_u4F1A_u5E26_u6765_u7684_u95EE_u9898_uFF0C_u5982_u4F55_u89E3_u51B3" class="headerlink" title="BaseAdapter中notifydatachanged原理,会带来的问题，如何解决"></a>BaseAdapter中notifydatachanged原理,会带来的问题，如何解决</h3><ul>
<li>问题1：使用notifydatachanged的时候，当数据源发生改变的时候，会导致整个view的重绘（比较消耗资源）。</li>
<li>解决方案：如果只是修改item的view上一个或几个简单的view时，判断此Item是否当前是否在页面显示，若获取此itemView进行特定view的更新。另外，如果是删除或者增加一个数据源时，这种方案就比较麻烦了，还是直接调用notifyDataChanged吧。</li>
<li>问题2：针对问题一的解决方案，发现增加或者删除数据源，就没用相应的方法了。这个也可以说是BaseAdapter设计的初衷就不是这样的吧，它的作用只是封装了数据源，只用来提供数据源的显示，没有提供数据源的操作。不过现在大家就可以看到在RecylcerView的adapter就提供了相应的ItemView的插入、删除、以及交换、更新等操作。</li>
</ul>
<h3 id="u56FE_u7247_u5217_u8868_u7684ListView_u6ED1_u52A8_u7684_u4F18_u5316"><a href="#u56FE_u7247_u5217_u8868_u7684ListView_u6ED1_u52A8_u7684_u4F18_u5316" class="headerlink" title="图片列表的ListView滑动的优化"></a>图片列表的ListView滑动的优化</h3><h3 id="Fragment_u4E2Dhide_u5230show_u4E4B_u540E_2C_u6240_u6267_u884C_u7684_u751F_u547D_u5468_u671F"><a href="#Fragment_u4E2Dhide_u5230show_u4E4B_u540E_2C_u6240_u6267_u884C_u7684_u751F_u547D_u5468_u671F" class="headerlink" title="Fragment中hide到show之后,所执行的生命周期"></a>Fragment中hide到show之后,所执行的生命周期</h3><p>### </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>针对Android中一些进阶的常用的知识点，做一些汇总：</p>
<h3 id="BaseAdapter_u4E2Dnotifydatachanged_u539F_u7406_2C_u4F1A_u5E26_u6765_u7684_u95EE_u9898_uFF0C_u598]]>
    </summary>
    
      <category term="Android进阶" scheme="http://david-wei.github.io/tags/Android%E8%BF%9B%E9%98%B6/"/>
    
      <category term="Android" scheme="http://david-wei.github.io/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MVP在Android中的应用]]></title>
    <link href="http://david-wei.github.io/2015/07/20/MVP%E5%9C%A8Android%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://david-wei.github.io/2015/07/20/MVP在Android中的应用/</id>
    <published>2015-07-20T15:54:29.000Z</published>
    <updated>2015-12-22T03:10:20.000Z</updated>
    <content type="html"><![CDATA[<p>想起之前遇到的一个面试问题，在Activity中你们项目的代码行数有多少行？<br>这便是考虑项目的结构以及架构的问题，在我现在遇到的Android项目代码编写中，由于Android不清晰的MVC结构的思想，在Activity、Fragment中不自觉地会与逻辑代码混杂在一起，不可避免地就会导致其代码结果过大，不利于复杂界面的后期维护修改。</p>
<h3 id="u89E3_u51B3_u65B9_u68481_uFF1A_u6CE8_u89E3_u65B9_u5F0F_u7684_u8FD0_u7528"><a href="#u89E3_u51B3_u65B9_u68481_uFF1A_u6CE8_u89E3_u65B9_u5F0F_u7684_u8FD0_u7528" class="headerlink" title="解决方案1：注解方式的运用"></a>解决方案1：注解方式的运用</h3><p>   在Android中，这个最常用的就是<a href="http://androidannotations.org/" target="_blank" rel="external">AndroidAnotations</a><br>   带来的好处是避免了输写过程的麻烦程度，但是对于项目的结构程序是没有任何帮助。</p>
<h3 id="u89E3_u51B3_u65B9_u68482_uFF1AMVP_u8BBE_u8BA1_u601D_u60F3_u7684_u8FD0_u7528"><a href="#u89E3_u51B3_u65B9_u68482_uFF1AMVP_u8BBE_u8BA1_u601D_u60F3_u7684_u8FD0_u7528" class="headerlink" title="解决方案2：MVP设计思想的运用"></a>解决方案2：MVP设计思想的运用</h3><p>   目的：使Model与View解耦，达到复杂的逻辑隔离开来的作用<br>   实现方式：通过Presenter来与二者进行交互，在Actiivty中保持一个对Presenter的调用，将view的调用以及交互效果抽象出来，来交由Presenter来管理，Model的修改又通过Presenter来影响view的更新<br>   <a href="https://github.com/antoniolg/androidmvp" target="_blank" rel="external">一个简单的登陆demo</a></p>
<h3 id="u89E3_u51B3_u65B9_u68483_uFF1AMVVM_u7684_u5B9E_u73B0"><a href="#u89E3_u51B3_u65B9_u68483_uFF1AMVVM_u7684_u5B9E_u73B0" class="headerlink" title="解决方案3：MVVM的实现"></a>解决方案3：MVVM的实现</h3><p>   目的：1.避免了view的查找与获取<br>         2.view的展示需要的数据，通过viewModel的概念来在xml文件中进行绑定<br>         3.更加清晰的视图结构</p>
<h3 id="u63A8_u8350_u7684_u4E24_u4E2A_u6846_u67B6_uFF1A"><a href="#u63A8_u8350_u7684_u4E24_u4E2A_u6846_u67B6_uFF1A" class="headerlink" title="推荐的两个框架："></a>推荐的两个框架：</h3><p>   <a href="https://github.com/android10/Android-CleanArchitecture" target="_blank" rel="external">Android-CleanArchitecture</a><br>   <a href="https://github.com/pedrovgs/EffectiveAndroidUI" target="_blank" rel="external">EffectiveAndroidUI</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>想起之前遇到的一个面试问题，在Activity中你们项目的代码行数有多少行？<br>这便是考虑项目的结构以及架构的问题，在我现在遇到的Android项目代码编写中，由于Android不清晰的MVC结构的思想，在Activity、Fragment中不自觉地会与逻辑代码混杂在一]]>
    </summary>
    
      <category term="MVP" scheme="http://david-wei.github.io/tags/MVP/"/>
    
      <category term="Android" scheme="http://david-wei.github.io/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[nested-fragments-onAcitivityResult]]></title>
    <link href="http://david-wei.github.io/2015/07/09/nested-fragments-onAcitivityResult/"/>
    <id>http://david-wei.github.io/2015/07/09/nested-fragments-onAcitivityResult/</id>
    <published>2015-07-09T14:31:59.000Z</published>
    <updated>2015-12-22T03:10:20.000Z</updated>
    <content type="html"><![CDATA[<p>在执行嵌套的fragment(fragment里面嵌套fragment)的onActivityResult，会发现是执行不到的。所以接下来就fragmentActivity和fragment的源码类来分析一下他们具体的逻辑：</p>
<h3 id="u5173_u952E_u70B9_uFF1AFragmentActivity_u7684startActivityFromFragment_u65B9_u6CD5"><a href="#u5173_u952E_u70B9_uFF1AFragmentActivity_u7684startActivityFromFragment_u65B9_u6CD5" class="headerlink" title="关键点：FragmentActivity的startActivityFromFragment方法"></a>关键点：FragmentActivity的startActivityFromFragment方法</h3><ol>
<li><p>FragmentActivity的startActivityForResult方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(Intent intent, <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (requestCode != -<span class="number">1</span> &amp;&amp; (requestCode&amp;<span class="number">0xffff0000</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Can only use lower 16 bits for requestCode"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.startActivityForResult(intent, requestCode);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从上可以看出来，如果是通过调用Activity的这个方法，它只允许使用requestCode的低16为。</p>
</li>
<li><p>FragmentAcitivity的startActivityFromFragment方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">  * Called by Fragment.startActivityForResult() to implement its behavior.</span><br><span class="line">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityFromFragment</span><span class="params">(Fragment fragment, Intent intent, </span><br><span class="line">         <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (requestCode == -<span class="number">1</span>) &#123;</span><br><span class="line">         super.startActivityForResult(intent, -<span class="number">1</span>);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> ((requestCode&amp;<span class="number">0xffff0000</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Can only use lower 16 bits for requestCode"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     super.startActivityForResult(intent, ((fragment.mIndex+<span class="number">1</span>)&lt;&lt;<span class="number">16</span>) + (requestCode&amp;<span class="number">0xffff</span>));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法是当调用fragment的startActivityForResult方法，便会调用到上面这个方法，这里做了一个处理是：将fragment的index(对应fragment在manager中对应的索引)放i在高16位，并保留低16位的requestCode.</p>
</li>
<li><p>FragmentActivity的onActivityResult方法</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">  * Dispatch incoming result to the correct fragment.</span><br><span class="line">  */</span></span><br><span class="line"> @Override</span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">void</span> onActivityResult(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data) &#123;</span><br><span class="line">     mFragments.noteStateNotSaved();</span><br><span class="line">     <span class="keyword">int</span> <span class="keyword">index</span> = requestCode&gt;&gt;<span class="number">16</span>;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">index</span> != <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">index</span>--;</span><br><span class="line">         <span class="keyword">if</span> (mFragments.mActive == <span class="keyword">null</span> || <span class="keyword">index</span> &lt; <span class="number">0</span> || <span class="keyword">index</span> &gt;= mFragments.mActive.size()) &#123;</span><br><span class="line">             Log.w(TAG, <span class="string">"Activity result fragment index out of range: 0x"</span></span><br><span class="line">                     + Integer.toHexString(requestCode));</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         Fragment frag = mFragments.mActive.get(<span class="keyword">index</span>);</span><br><span class="line">         <span class="keyword">if</span> (frag == <span class="keyword">null</span>) &#123;</span><br><span class="line">             Log.w(TAG, <span class="string">"Activity result no fragment exists for index: 0x"</span></span><br><span class="line">                     + Integer.toHexString(requestCode));</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             frag.onActivityResult(requestCode&amp;<span class="number">0xffff</span>, resultCode, data);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>根据之前的逻辑，在这里就需要对高16位的数值，进行判断，当不为0时，根据对应的fragment的index值，获取到对应的fragment的onActivityResult方法。若高16位的数值为0，则表示是activity对应的方法。</p>
</li>
</ol>
<h3 id="u89E3_u51B3_u4E4B_u9053"><a href="#u89E3_u51B3_u4E4B_u9053" class="headerlink" title="解决之道"></a>解决之道</h3><ol>
<li>fragment的层数<ul>
<li>我们在这里可认为第一层的fragment（放在Activity之中）,由getFragmentManager来管理 </li>
<li>嵌套的fragment是通过getChildFragmentManager来获取的。</li>
</ul>
</li>
<li>层数和index的存放<br>根据FragmentActivity存放fragment的index的原理，我们可以根据指定位数来存放fragment的层数以及index的相关信息。</li>
<li>代码（show me the code）<br>找到一篇github上的代码，就不贴我的代码了，思路就是这个思路。<br><a href="https://github.com/shamanland/nested-fragment-issue" target="_blank" rel="external">nested-fragment-issue</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>在执行嵌套的fragment(fragment里面嵌套fragment)的onActivityResult，会发现是执行不到的。所以接下来就fragmentActivity和fragment的源码类来分析一下他们具体的逻辑：</p>
<h3 id="u5173_u952E_]]>
    </summary>
    
      <category term="fragment" scheme="http://david-wei.github.io/tags/fragment/"/>
    
      <category term="Android" scheme="http://david-wei.github.io/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Webview 支持 input type=file]]></title>
    <link href="http://david-wei.github.io/2015/07/07/Webview-%E6%94%AF%E6%8C%81-input-type-file/"/>
    <id>http://david-wei.github.io/2015/07/07/Webview-支持-input-type-file/</id>
    <published>2015-07-06T23:27:44.000Z</published>
    <updated>2015-12-22T03:10:20.000Z</updated>
    <content type="html"><![CDATA[<p>在一个带有input tpye=file标签的Html页面，通过WebView，上传android手机上的图片，发现不工作。（在Ios和微信上完全正常工作）所以，需要研究一下Android的WebView，来支持type=file的标签。</p>
<h3 id="WebView_u8BBE_u7F6EWebChromeClient"><a href="#WebView_u8BBE_u7F6EWebChromeClient" class="headerlink" title="WebView设置WebChromeClient"></a>WebView设置WebChromeClient</h3><p>  重写WebChromeClient中关于文件选择的方法，onShowFileChooser和openFileChooser。(项目中只需要选择图片，所以加上了图片过滤。)</p>
<pre><code>public static final int INPUT_FILE_REQUEST_CODE = 1;
private ValueCallback&lt;Uri&gt; mUploadMessage;
private final static int FILECHOOSER_RESULTCODE = 2;
private ValueCallback&lt;Uri[]&gt; mFilePathCallback;

private String mCameraPhotoPath;
private WebChromeClient mWebChromeClient = new WebChromeClient() {

    // android 5.0
    public boolean onShowFileChooser(
            WebView webView, ValueCallback&lt;Uri[]&gt; filePathCallback,
            WebChromeClient.FileChooserParams fileChooserParams) {
        if (mFilePathCallback != null) {
            mFilePathCallback.onReceiveValue(null);
        }
        mFilePathCallback = filePathCallback;

        Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
        if (takePictureIntent.resolveActivity(getPackageManager()) != null) {
            // Create the File where the photo should go
            File photoFile = null;
            try {
                photoFile = createImageFile();
                takePictureIntent.putExtra(&quot;PhotoPath&quot;, mCameraPhotoPath);
            } catch (IOException ex) {
                // Error occurred while creating the File
                Log.e(&quot;WebViewSetting&quot;, &quot;Unable to create Image File&quot;, ex);
            }

            // Continue only if the File was successfully created
            if (photoFile != null) {
                mCameraPhotoPath = &quot;file:&quot; + photoFile.getAbsolutePath();
                takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT,
                        Uri.fromFile(photoFile));
            } else {
                takePictureIntent = null;
            }
        }

        Intent contentSelectionIntent = new Intent(Intent.ACTION_GET_CONTENT);
        contentSelectionIntent.addCategory(Intent.CATEGORY_OPENABLE);
        contentSelectionIntent.setType(&quot;image/*&quot;);

        Intent[] intentArray;
        if (takePictureIntent != null) {
            intentArray = new Intent[]{takePictureIntent};
        } else {
            intentArray = new Intent[0];
        }

        Intent chooserIntent = new Intent(Intent.ACTION_CHOOSER);
        chooserIntent.putExtra(Intent.EXTRA_INTENT, contentSelectionIntent);
        chooserIntent.putExtra(Intent.EXTRA_TITLE, &quot;Image Chooser&quot;);
        chooserIntent.putExtra(Intent.EXTRA_INITIAL_INTENTS, intentArray);

        startActivityForResult(chooserIntent, INPUT_FILE_REQUEST_CODE);

        return true;
    }

    //The undocumented magic method override
    //Eclipse will swear at you if you try to put @Override here
    // For Android 3.0+
    public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg) {

        mUploadMessage = uploadMsg;
        Intent i = new Intent(Intent.ACTION_GET_CONTENT);
        i.addCategory(Intent.CATEGORY_OPENABLE);
        i.setType(&quot;image/*&quot;);
        WebViewActivity.this.startActivityForResult(Intent.createChooser(i, &quot;Image Chooser&quot;), FILECHOOSER_RESULTCODE);

    }

    // For Android 3.0+
    public void openFileChooser(ValueCallback uploadMsg, String acceptType) {
        mUploadMessage = uploadMsg;
        Intent i = new Intent(Intent.ACTION_GET_CONTENT);
        i.addCategory(Intent.CATEGORY_OPENABLE);
        i.setType(&quot;image/*&quot;);
        WebViewActivity.this.startActivityForResult(
                Intent.createChooser(i, &quot;Image Chooser&quot;),
                FILECHOOSER_RESULTCODE);
    }

    //For Android 4.1
    public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType, String capture) {
        mUploadMessage = uploadMsg;
        Intent i = new Intent(Intent.ACTION_GET_CONTENT);
        i.addCategory(Intent.CATEGORY_OPENABLE);
        i.setType(&quot;image/*&quot;);
        WebViewActivity.this.startActivityForResult(Intent.createChooser(i, &quot;Image Chooser&quot;), WebViewActivity.FILECHOOSER_RESULTCODE);

    }
};
</code></pre><h3 id="u9009_u62E9_u7ED3_u679C_u7684_u56DE_u8C03"><a href="#u9009_u62E9_u7ED3_u679C_u7684_u56DE_u8C03" class="headerlink" title="选择结果的回调"></a>选择结果的回调</h3><p>  在onActivityResult中获取对应的选取文件的返回结果</p>
<pre><code>public void onActivityResult(int requestCode, int resultCode, Intent data) {
    if (requestCode == FILECHOOSER_RESULTCODE) {
        if (null == mUploadMessage) return;
        Uri result = data == null || resultCode != RESULT_OK ? null
                : data.getData();
        if (result != null) {
            String imagePath = ImageFilePath.getPath(this, result);
            if (!StrUtils.isEmpty(imagePath)) {
                result = Uri.parse(&quot;file:///&quot; + imagePath);
            }
        }
        mUploadMessage.onReceiveValue(result);
        mUploadMessage = null;
    } else if (requestCode == INPUT_FILE_REQUEST_CODE &amp;&amp; mFilePathCallback != null) {
        // 5.0的回调
        Uri[] results = null;

        // Check that the response is a good one
        if (resultCode == Activity.RESULT_OK) {
            if (data == null) {
                // If there is not data, then we may have taken a photo
                if (mCameraPhotoPath != null) {
                    Logger.d(&quot;camera_photo_path&quot;, mCameraPhotoPath);
                    results = new Uri[]{Uri.parse(mCameraPhotoPath)};
                }
            } else {
                String dataString = data.getDataString();
                Logger.d(&quot;camera_dataString&quot;, dataString);
                if (dataString != null) {
                    results = new Uri[]{Uri.parse(dataString)};
                }
            }
        }

        mFilePathCallback.onReceiveValue(results);
        mFilePathCallback = null;
    } else {
        super.onActivityResult(requestCode, resultCode, data);
        return;
    }
}
</code></pre><h3 id="u6587_u4EF6_u8DEF_u5F84_u7684_u83B7_u53D6"><a href="#u6587_u4EF6_u8DEF_u5F84_u7684_u83B7_u53D6" class="headerlink" title="文件路径的获取"></a>文件路径的获取</h3><p>  返回文件的解析，因为html页面需要的是文件，所以客户端需要返回的是对应文件的路径。这样，就会存在一个问题，在Android 4.4上，通过文件选择返回的结果都是对应以content开头格式的对应的路径。这就得需要咱们来进行判断，最终都需要转回成以file开头对应的格式文件。下面，我封装成了一个ImageFilePath的类，通过调用getPath方法来获取最终的结果。这个类的方法如下：</p>
<pre><code> /**
 * Method for return file path of Gallery image
 *
 * @param context
 * @param uri
 * @return path of the selected image file from gallery
 */
 public static String getPath(final Context context, final Uri uri) {

    // check here to KITKAT or new version
    final boolean isKitKat = Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT;

    // DocumentProvider
    if (isKitKat &amp;&amp; DocumentsContract.isDocumentUri(context, uri)) {

        // ExternalStorageProvider
        if (isExternalStorageDocument(uri)) {
            final String docId = DocumentsContract.getDocumentId(uri);
            final String[] split = docId.split(&quot;:&quot;);
            final String type = split[0];

            if (&quot;primary&quot;.equalsIgnoreCase(type)) {
                return Environment.getExternalStorageDirectory() + &quot;/&quot;
                        + split[1];
            }
        }
        // DownloadsProvider
        else if (isDownloadsDocument(uri)) {

            final String id = DocumentsContract.getDocumentId(uri);
            final Uri contentUri = ContentUris.withAppendedId(
                    Uri.parse(&quot;content://downloads/public_downloads&quot;),
                    Long.valueOf(id));

            return getDataColumn(context, contentUri, null, null);
        }
        // MediaProvider
        else if (isMediaDocument(uri)) {
            final String docId = DocumentsContract.getDocumentId(uri);
            final String[] split = docId.split(&quot;:&quot;);
            final String type = split[0];

            Uri contentUri = null;
            if (&quot;image&quot;.equals(type)) {
                contentUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;
            } else if (&quot;video&quot;.equals(type)) {
                contentUri = MediaStore.Video.Media.EXTERNAL_CONTENT_URI;
            } else if (&quot;audio&quot;.equals(type)) {
                contentUri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;
            }

            final String selection = &quot;_id=?&quot;;
            final String[] selectionArgs = new String[] { split[1] };

            return getDataColumn(context, contentUri, selection,
                    selectionArgs);
        }
    }
    // MediaStore (and general)
    else if (&quot;content&quot;.equalsIgnoreCase(uri.getScheme())) {

        // Return the remote address
        if (isGooglePhotosUri(uri))
            return uri.getLastPathSegment();

        return getDataColumn(context, uri, null, null);
    }
    // File
    else if (&quot;file&quot;.equalsIgnoreCase(uri.getScheme())) {
        return uri.getPath();
    }

    return null;
}

/**
 * Get the value of the data column for this Uri. This is useful for
 * MediaStore Uris, and other file-based ContentProviders.
 *
 * @param context
 *            The context.
 * @param uri
 *            The Uri to query.
 * @param selection
 *            (Optional) Filter used in the query.
 * @param selectionArgs
 *            (Optional) Selection arguments used in the query.
 * @return The value of the _data column, which is typically a file path.
 */
public static String getDataColumn(Context context, Uri uri,
                                   String selection, String[] selectionArgs) {

    Cursor cursor = null;
    final String column = &quot;_data&quot;;
    final String[] projection = { column };

    try {
        cursor = context.getContentResolver().query(uri, projection,
                selection, selectionArgs, null);
        if (cursor != null &amp;&amp; cursor.moveToFirst()) {
            final int index = cursor.getColumnIndexOrThrow(column);
            return cursor.getString(index);
        }
    } finally {
        if (cursor != null)
            cursor.close();
    }
    return null;
}

/**
 * @param uri
 *            The Uri to check.
 * @return Whether the Uri authority is ExternalStorageProvider.
 */
public static boolean isExternalStorageDocument(Uri uri) {
    return &quot;com.android.externalstorage.documents&quot;.equals(uri
            .getAuthority());
}

/**
 * @param uri
 *            The Uri to check.
 * @return Whether the Uri authority is DownloadsProvider.
 */
public static boolean isDownloadsDocument(Uri uri) {
    return &quot;com.android.providers.downloads.documents&quot;.equals(uri
            .getAuthority());
}

/**
 * @param uri
 *            The Uri to check.
 * @return Whether the Uri authority is MediaProvider.
 */
public static boolean isMediaDocument(Uri uri) {
    return &quot;com.android.providers.media.documents&quot;.equals(uri
            .getAuthority());
}

/**
 * @param uri
 *            The Uri to check.
 * @return Whether the Uri authority is Google Photos.
 */
public static boolean isGooglePhotosUri(Uri uri) {
    return &quot;com.google.android.apps.photos.content&quot;.equals(uri
            .getAuthority());
}
</code></pre><h3 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h3><p> <a href="http://stackoverflow.com/questions/5907369/file-upload-in-webview" target="_blank" rel="external">file-upload-in-webview</a><br> <a href="http://stackoverflow.com/questions/20067508/get-real-path-from-uri-android-kitkat-new-storage-access-framework" target="_blank" rel="external">get-real-path-from-uri-android-kitkat-new-storage-access-framework</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在一个带有input tpye=file标签的Html页面，通过WebView，上传android手机上的图片，发现不工作。（在Ios和微信上完全正常工作）所以，需要研究一下Android的WebView，来支持type=file的标签。</p>
<h3 id="WebVi]]>
    </summary>
    
      <category term="Webview" scheme="http://david-wei.github.io/tags/Webview/"/>
    
      <category term="Android" scheme="http://david-wei.github.io/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hexo 初步搭建]]></title>
    <link href="http://david-wei.github.io/2015/07/03/hexo-%E6%90%AD%E5%BB%BA/"/>
    <id>http://david-wei.github.io/2015/07/03/hexo-搭建/</id>
    <published>2015-07-02T19:00:00.000Z</published>
    <updated>2015-12-22T03:10:20.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start"><a href="#Quick_Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create_a_new_post"><a href="#Create_a_new_post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server"><a href="#Run_server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files"><a href="#Generate_static_files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites"><a href="#Deploy_to_remote_sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io]]>
    </summary>
    
      <category term="hexo" scheme="http://david-wei.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
